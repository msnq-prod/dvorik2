1. Общие правила работы с проектом

Ты работаешь с существующим репозиторием dvorikfinal (монорепо с папками типа server/, client/, shared/).

Стек менять нельзя:

Бэкенд: остаётся Node.js + Express + Drizzle (PostgreSQL).

Фронтенд: остаётся React + Vite (или аналогичный уже настроенный стек).

Любые изменения делай минимально инвазивно:

Не переписывай файлы “с нуля”, если не нужно.

По возможности редактируй только нужные фрагменты.

Для каждой задачи:

Просмотри структуру файлов (дерево репозитория).

Найди соответствующие файлы/модули.

Сформируй короткий план изменений.

Применяй изменения по шагам.

После правок убедись, что проект собирается и запускается (используй существующие npm-скрипты).

Соблюдай текущий стиль кода:

Те же паттерны импорта/экспорта.

Те же соглашения именования.

Те же способы работы c Drizzle и React.

Не удаляй и не ломай уже реализованные эндпоинты и UI-страницы, если в явной форме не требуется рефакторинг.

2. Глобальная цель

Сделать из проекта dvorikfinal полноценную систему управления клиентами и скидками с:

Админ-панелью для владельца/маркетолога/наблюдателя.

Двумя Telegram-ботами:

Основной бот для клиентов.

Бот для кассиров.

Гибкой системой скидок, кампаний, сегментов и рассылок.

Логированием всех ключевых действий (скидки, кассиры, админы, подписка).

Фоновыми задачами (рассылки, поздравления с ДР, напоминания).

Дашбордом с базовой аналитикой.

Дальнейшие этапы описывают, как этого добиться.

3. Этап A. Нормализация окружения и базовая документация

Цель: привести проект к состоянию, в котором его легко запускать, и зафиксировать текущее состояние.

Шаги:

Найди в корне репозитория package.json (или несколько в server/, client/).

Определи, как сейчас запускается:

сервер (Express + Drizzle),

клиент (React),

миграции БД (если есть).

Создай/обнови файл .env.example в корне монорепо:

Переменные для бэкенда:

DATABASE_URL

JWT_SECRET

TELEGRAM_MAIN_BOT_TOKEN

TELEGRAM_CASHIER_BOT_TOKEN

TELEGRAM_MAIN_CHANNEL_ID (канал/группа для проверки подписки)

APP_BASE_URL (админка)

WEBHOOK_BASE_URL (бэкенд, где будут вебхуки ботов)

При необходимости добавь остальные переменные, которые уже используются в коде.

Создай файл server/config.ts (если его ещё нет) c чтением переменных окружения и экспортом настроек (URL БД, токены, секреты).

Создай файл docs/current-state.md, в котором:

Перечисли существующие таблицы из shared/schema.ts.

Перечисли существующие эндпоинты из server/routes.ts (в формате: метод + путь + краткое описание).

Перечисли основные страницы фронтенда из client/src/pages.

4. Этап B. Расширение модели данных

Цель: привести схему БД к целевой функциональности (клиенты, скидки, логи, сегменты, кампании, рассылки, рефералы, подписка).

Работай в файле shared/schema.ts (или аналогичном, где описаны таблицы Drizzle).

B1. Таблицы сущностей

Добавь/расширь таблицы так, чтобы в БД были:

Пользователи (users)
Поля, помимо уже существующих:

telegram_id (уникальный идентификатор пользователя в Telegram).

username (handle в Telegram, если есть).

first_name, last_name.

phone (опционально).

birthday (дата рождения).

gender (строка или enum).

city (строка).

tags (массив строк или JSON).

lead_source_id (внешний ключ на lead_sources).

created_at, updated_at.

Администраторы (admins)
Добавь поле:

role — enum 'owner' | 'marketing' | 'viewer'.
owner — полный доступ, marketing — маркетинг/рассылки, viewer — просмотр.

Кассиры (cashiers)

id

name

telegram_id (уникальный идентификатор кассира в Telegram).

code (код магазина/кассира для первичной авторизации).

created_at, updated_at.

Источники лидов (lead_sources)

id

code (строковый код для start-параметров и аналитики, уникальный).

name (человекочитаемое название, напр. “Instagram”, “Оффлайн QR”, “Реферальная ссылка кампании X”).

created_at, updated_at.

Реферальные кампании (referral_campaigns)

id

code (короткий код кампании, используется в реферальных ссылках).

name

description

is_active (bool)

created_at, updated_at.

Реферальные события (referral_events)

id

campaign_id (FK → referral_campaigns)

referrer_user_id (пригласивший пользователь, FK → users)

referred_user_id (приглашённый пользователь, FK → users)

event_type (enum: 'joined' | 'first_purchase' | 'discount_redeemed' и т.п.)

payload (JSON с доп. инфой).

created_at.

Шаблоны скидок (discount_templates)
Дополнительно к текущим полям:

name

description

discount_type ('percent' | 'fixed').

value (число, % или фикс).

min_order_amount (опционально).

valid_days (сколько дней действует скидка после выдачи).

max_usage_per_user (ограничение по количеству для одного пользователя).

context (JSON для различных сценариев: акция, ДР, реферальная и т. д.).

Скидки (discounts)
Дополнительно к текущим полям:

code (уникальный код скидки, строка).

template_id (FK → discount_templates).

user_id (FK → users).

status (enum: 'created' | 'issued' | 'redeemed' | 'expired' | 'cancelled').

issued_at

redeemed_at

valid_until

source (строка или enum, напр. 'main_bot' | 'cashier_bot' | 'manual' | 'birthday').

cashier_id (FK → cashiers, nullable).

payload (JSON).

Логи использования скидок (discount_usage_logs)

id

discount_id (FK → discounts)

user_id (FK → users)

cashier_id (FK → cashiers, nullable)

event_type (enum: 'issued' | 'redeem_attempt' | 'redeemed' | 'expired' | 'cancelled')

success (bool)

reason (строка, объясняющая отказ при неуспешном использовании)

created_at

source (источник события, строка/enum).

Рассылки (broadcasts)

id

title

message (текст сообщения, которое будет отправлено пользователям)

segment_id (FK → segments, nullable; если null — “по всем”)

scheduled_at (дата/время плановой отправки)

status (enum: 'planned' | 'processing' | 'completed' | 'failed')

created_by_admin_id (FK → admins)

created_at, updated_at.

Логи рассылок (broadcast_logs)

id

broadcast_id (FK → broadcasts)

user_id (FK → users)

status (enum: 'sent' | 'failed')

error_message (nullable, строка)

created_at.

Настройки (settings)
(Если уже есть — расширь, не ломая текущую логику.)

key (строка, primary key)

value (JSON или строка)

updated_at.

Проверка подписки на канал (subscription_checks)

id

user_id (FK → users)

channel_id (строка, идентификатор канала/чата)

is_subscribed (bool)

checked_at.

Аудит действий админов (audit_logs)

id

admin_id (FK → admins)

action (строка, напр. 'create_discount_template', 'update_broadcast', 'delete_campaign')

payload (JSON с деталями)

created_at.

Сегменты (segments) — динамические сегменты по фильтрам

id

name

description

filter (JSON, описывающий правила отбора пользователей: возраст, город, наличие подписки, наличие активных скидок и т. д.)

created_by_admin_id (FK → admins)

created_at, updated_at.

Общие события (event_logs)

Если уже есть — приведи к консистентному виду:

id

event_type (строка/enum)

entity_type (строка: 'user' | 'discount' | 'broadcast' | 'bot' | ...)

entity_id (строка/число)

payload (JSON)

created_at.

B2. Миграции

Если Drizzle-миграции уже используются — добавь соответствующие миграции.

Если миграций нет — настрой Drizzle config, чтобы схема могла быть развернута через миграции, а не только push.

Убедись, что после миграций проект поднимается, а существующие данные (если есть) не ломаются.

5. Этап C. Слой данных (server/storage.ts)

Цель: все операции с БД должны проходить через хорошо структурированные функции, которые потом будут использоваться роутами и ботами.

Шаги:

Открой server/storage.ts (или аналогичный модуль доступа к БД).

Для каждой сущности из Этапа B добавь набор функций:

Примеры:

Для пользователей:

createUserFromTelegram(profile, options) — создать или обновить пользователя по telegram_id, заполнить профиль.

getUserByTelegramId(telegramId)

updateUser(id, data)

listUsers(filters, pagination)

Для кассиров:

getCashierByTelegramId(telegramId)

getCashierByCode(code)

linkCashierTelegram(cashierId, telegramId)

Для источников лидов:

getLeadSourceByCode(code)

listLeadSources()

createLeadSource(data)

Для шаблонов скидок:

listDiscountTemplates()

createDiscountTemplate(data)

updateDiscountTemplate(id, data)

deleteDiscountTemplate(id)

Для скидок:

issueDiscountForUser(userId, templateId, context):

Проверяет ограничения шаблона (количество, сроки).

Создаёт запись discounts со статусом issued.

Вычисляет valid_until по valid_days.

Создаёт запись в discount_usage_logs с event_type='issued'.

Создаёт запись в event_logs.

redeemDiscountByCode(code, cashierId, source):

Находит скидку по code.

Проверяет статус (issued только).

Проверяет valid_until.

Если всё ok:

Обновляет статус на redeemed, ставит redeemed_at, cashier_id.

Добавляет запись в discount_usage_logs с event_type='redeemed', success=true.

Добавляет запись в event_logs.

Если не ok:

Не меняет скидку.

Добавляет запись discount_usage_logs с success=false и причиной.

Возвращает понятный результат.

Для рассылок:

createBroadcast(data)

listBroadcasts(filters)

getBroadcast(id)

updateBroadcast(id, data)

logBroadcastResult(broadcastId, userId, status, errorMessage?)

Для сегментов:

createSegment(data)

updateSegment(id, data)

listSegments()

getSegment(id)

previewSegmentUsers(segmentId, limit) — строит SQL по filter JSON и возвращает несколько пользователей.

Для логов:

logSubscriptionCheck(userId, channelId, isSubscribed)

logAdminAction(adminId, action, payload)

logEvent(eventType, entityType, entityId, payload)

Там, где операция затрагивает несколько таблиц (скидки и логи), используй транзакции Drizzle.

6. Этап D. Роли, авторизация и защита роутов

Цель: реализовать модель ролей (owner, marketing, viewer) и защитить эндпоинты.

Шаги:

Проверь, как сейчас реализован логин в админку:

Если логина нет — добавь простой вариант через email/пароль для admins.

Добавь JWT-аутентификацию:

Эндпоинт POST /api/auth/login:

Принимает email/пароль.

Находит админа.

Сравнивает пароль (хранить в хеше, использовать bcrypt или аналог).

Возвращает JWT с adminId и role.

Middleware requireAdmin(role?):

Проверяет JWT.

Вытаскивает adminId и role.

Если указан requiredRole:

Разрешает доступ, если роль не “ниже” требуемой.

Применить requireAdmin к существующим эндпоинтам:

Управление админами, настройками, опасными операциями — только owner.

Управление скидками, кампаниями, рассылками — owner и marketing.

Просмотр статистики, логов — owner, marketing, viewer.

На фронтенде:

Хранить JWT в безопасном месте (session/local storage, как принято в проекте).

В контексте/сторе держать информацию о текущем админе и его роли.

Скрывать/блокировать UI-элементы, недоступные для данных ролей.

7. Этап E. Основной Telegram-бот (клиентский)

Цель: реализовать основной Telegram-бот для клиентов, который умеет:

Регистрировать/обновлять пользователей.

Проверять подписку на канал.

Выдавать скидки.

Запрашивать дату рождения.

Работать с реферальными сценариями.

Шаги:

Выбери библиотеку (если её ещё нет) — telegraf или grammy. Добавь её в зависимости server.

Создай в server/bots/mainBot.ts модуль с:

Инициализацией бота с токеном TELEGRAM_MAIN_BOT_TOKEN.

Функцией handleMainBotUpdate(update), которая:

Принимает update от Telegram (объект JSON).

Обрабатывает команды и сообщения.

В server/routes.ts:

Внутри обработчика POST /api/bot/main/webhook:

Передавай req.body в handleMainBotUpdate.

Возвращай 200 OK после обработки.

Реализуй сценарий /start:

Разбор аргумента start (может содержать код кампании или источника).

Получение/создание пользователя:

По telegram_id из update.message.from.

Обновление профиля (username, имя, язык).

Привязка lead_source_id, если start содержит код источника.

Возможная привязка к реферальной кампании:

Если start содержит код кампании/реферала → создание referral_events нужного типа.

Ответ пользователю:

Приветственное сообщение.

Меню с вариантами (“Получить скидку”, “Мой профиль”, “Указать дату рождения” и т. п.).

Реализуй проверку подписки:

При необходимости (перед выдачей скидки) бот должен:

Вызвать метод Telegram API getChatMember для TELEGRAM_MAIN_CHANNEL_ID.

Определить, подписан пользователь или нет.

Записать запись в subscription_checks.

Если не подписан — попросить подписаться, дать ссылку на канал и не выдавать скидку.

Реализуй выдачу скидки:

Команда или inline-кнопка “Получить скидку”:

Проверяет, есть ли у пользователя активная неиспользованная скидка (по правилам: например, одна действующая в момент времени).

Если уже есть — отправляет информацию о существующей скидке (код, срок действия).

Если нет — вызывает issueDiscountForUser с нужным шаблоном.

Отправляет пользователю код скидки (при желании можно добавить QR, но это опционально).

Всё логируется через discount_usage_logs.

Реализуй сбор даты рождения:

Команда/кнопка “Указать дату рождения”:

Выставляет пользователю состояние (FSM).

Следующее текстовое сообщение воспринимается как дата (формат DD.MM.YYYY или другой).

Валидирует дату.

Сохраняет в users.birthday.

Подтверждает успешное сохранение.

Реализуй базовый реферальный сценарий:

Когда пользователь приходит по реферальной ссылке (код в /start):

Находится соответствующая реферальная кампания/пригласивший.

Создаётся запись referral_events с типом 'joined'.

При первом использовании скидки реферала (см. redeemDiscountByCode) можно создавать referral_events для 'discount_redeemed'.

8. Этап F. Бот кассиров

Цель: реализовать отдельный Telegram-бот для кассиров, который позволяет проверять и погашать скидки.

Шаги:

Создай модуль server/bots/cashierBot.ts с функцией handleCashierBotUpdate(update).

В server/routes.ts:

Внутри POST /api/bot/cashier/webhook передавай req.body в handleCashierBotUpdate.

Реализуй авторизацию кассира:

Команда /start:

Спрашивает у пользователя код кассира/магазина.

Получает текстовый ответ.

Ищет кассира по code в таблице cashiers.

Если найден — привязывает telegram_id к кассиру (через linkCashierTelegram).

Сохраняет факт авторизации (можно хранить в БД или исходить из наличия telegram_id).

Отправляет подтверждение.

Реализуй погашение скидки:

После авторизации кассир может отправить боту код скидки (текстом).

Бот:

Вызывает redeemDiscountByCode с cashierId и source='cashier_bot'.

Получает результат: успешное погашение или отказ с причиной.

Отправляет понятный ответ кассиру (сумма, тип скидки, причина отказа).

Каждая попытка погашения логируется в discount_usage_logs (event_type='redeem_attempt', success=true/false) и, при необходимости, в audit_logs.

9. Этап G. API и админка для сегментов, кампаний, рассылок

Цель: дать маркетологу/владельцу интерфейс для работы c сегментами, кампаниями и рассылками.

G1. Сегменты

Бэкенд:

Добавь эндпоинты:

GET /api/segments — список сегментов.

POST /api/segments — создание сегмента.

GET /api/segments/:id — получение сегмента.

PATCH /api/segments/:id — обновление сегмента.

DELETE /api/segments/:id — удаление сегмента.

POST /api/segments/:id/preview — вернуть первые N пользователей, попадающих под фильтр.

Реализуй обработку filter JSON:

Упростить формат: например, массив условий [ { field, operator, value } ].

Для превью:

Собрать SQL SELECT по таблице users, учитывая условия (город, наличие ДР, наличие активных скидок и т. п.).

Вернуть ограниченное количество строк (например, 20).

Фронтенд:

Создай страницу Segments (если её нет):

Таблица сегментов (название, описание, кол-во условий, дата создания).

Кнопка “Создать сегмент”.

Форма создания/редактирования:

Поле “Название”.

Поле “Описание”.

Конструктор условий:

Поле (select: возраст, город, наличие подписки, наличие активных скидок и т. д.).

Оператор (=, >, <, contains и т. п.).

Значение.

Кнопка “Предпросмотр”:

Вызывает POST /api/segments/:id/preview.

Показывает список примерных пользователей.

G2. Кампании и рассылки

Бэкенд:

Убедись, что таблицы campaigns и broadcasts существуют и связаны с segments и users (через логи).

Для рассылок:

Эндпоинты:

GET /api/broadcasts

POST /api/broadcasts

GET /api/broadcasts/:id

PATCH /api/broadcasts/:id

GET /api/broadcasts/:id/logs

При создании/обновлении рассылки:

Валидируй обязательные поля (текст, сегмент или режим “по всем”, время отправки).

Записывай created_by_admin_id и status='planned'.

Фронтенд:

Страница Broadcasts:

Таблица рассылок (название, статус, время отправки, сегмент).

Форма создания/редактирования рассылки:

Заголовок.

Текст сообщения.

Выбор сегмента (или “по всем”).

Время отправки (немедленно/запланированное).

Страница логов рассылки:

Таблица broadcast_logs для конкретной рассылки:

Пользователь, статус, ошибка (если была).

10. Этап H. Фоновые задачи и обработка рассылок/напоминаний

Цель: автоматизировать рассылки и спец-сценарии (ДР, напоминания, очистка логов).

Шаги:

Создай отдельный процесс воркера, например server/worker.ts.

Добавь зависимости:

Для простого cron: node-cron.

При необходимости для очередей: bullmq и Redis (опционально; если в проекте уже есть Redis — используй его).

В worker.ts:

Инициализируй подключение к БД.

Настрой планировщик задач.

Реализуй задачу обработки рассылок:

Периодически (например, каждую минуту) искать broadcasts со статусом planned и scheduled_at <= now.

Для каждой:

Определить набор пользователей:

Если указан segment_id → построить запрос по сегменту.

Если нет сегмента → все пользователи.

Для каждого пользователя:

Отправить сообщение через Telegram-бот (основной).

Зафиксировать результат в broadcast_logs.

В случае ошибок делать ограниченное количество ретраев.

По окончании:

Установить status='completed' или status='failed' при критической ошибке.

Реализуй задачу “Поздравление с ДР”:

Ежедневно (например, в 10:00):

Найти всех пользователей, у которых сегодня дата рождения (по дню и месяцу).

Для каждого:

Выдать скидку с использованием специального шаблона (ДР).

Отправить через бота персональное поздравление и код.

Зафиксировать всё в логах.

Реализуй задачу “Напоминание о неиспользованных скидках”:

Один раз в день:

Найти скидки в статусе issued, у которых valid_until скоро истечёт (например, через 1–2 дня).

Отправить пользователям напоминание через бота.

Логировать эти отправки (можно через broadcasts/broadcast_logs или напрямую).

Реализуй задачу “Очистка старых логов”:

Например, раз в неделю:

Удалять/архивировать записи event_logs, subscription_checks, broadcast_logs, discount_usage_logs старше определённого срока (напр. 6 месяцев).

Не ломай целостность (оставляй связанные ключевые записи, если они нужны для аналитики).

11. Этап I. Дашборд и аналитика

Цель: предоставить сводную аналитику в админке.

Шаги:

В бэкенде расширь эндпоинт GET /api/dashboard/stats (или создай, если его нет), чтобы он возвращал:

Общее количество пользователей.

Количество новых пользователей за последние 7/30 дней.

Количество выданных и погашенных скидок за период.

Конверсию “выдано → погашено”.

ТОП кампаний по числу привлечённых пользователей.

ТОП кассиров по числу успешных погашений.

Распределение пользователей по источникам лидов (lead_sources).

В server/storage.ts создай функции:

getUserStats(period)

getDiscountStats(period)

getCashierStats(period)

getCampaignStats(period)

getLeadSourceStats(period)

На фронтенде в client/src/pages/dashboard.tsx:

Добавь загрузку данных с /api/dashboard/stats.

Выведи:

KPI-плашки (плитки) с ключевыми цифрами.

График (Recharts) по новым пользователям.

Пирог/бар-чарт по источникам лидов.

Таблицу ТОП кампаний и ТОП кассиров.

12. Этап J. Логи и аудит в админке

Цель: дать доступ к логам событий и действиям админов.

Шаги:

На бэкенде:

Эндпоинты:

GET /api/logs/events — список event_logs (с фильтрами по типу/дате).

GET /api/logs/discount-usage — discount_usage_logs.

GET /api/logs/audit — audit_logs.

В ключевых местах кода используй helper-функции:

logAdminAction(adminId, action, payload)

logEvent(eventType, entityType, entityId, payload)

logDiscountUsage(...)

На фронтенде:

Создай страницу Logs с вкладками:

“События” (event_logs).

“Скидки” (discount_usage_logs).

“Действия админов” (audit_logs).

Для каждой вкладки:

Таблица с пагинацией.

Фильтры по дате, типу, пользователю/админу.

13. Этап K. Экспорт данных

Цель: дать возможность выгружать данные в CSV для последующей аналитики.

Шаги:

На бэкенде:

Эндпоинты:

GET /api/users/export — экспорт пользователей.

GET /api/discounts/export — экспорт скидок.

GET /api/logs/discount-usage/export

GET /api/logs/audit/export

Возвращай text/csv с корректным заголовком Content-Disposition.

На фронтенде:

Добавь кнопки “Экспорт CSV” на страницах пользователей, скидок, логов.

По клику делай запрос к соответствующему эндпоинту и инициируй скачивание файла.

14. Этап L. Тесты и финальная проверка

Цель: убедиться, что ключевая бизнес-логика работает корректно и стабильно.

Шаги:

Добавь unit-тесты (Jest или уже используемый фреймворк) для функций:

issueDiscountForUser

redeemDiscountByCode

Логика сегментов (преобразование filter → SQL-запрос).

Добавь несколько интеграционных тестов для:

/api/discounts/redeem

/api/bot/main/webhook (обработка /start и выдача скидки).

/api/bot/cashier/webhook (погашение скидки).

Запусти тесты, исправь ошибки.

Пройдись по всем реализованным возможностям:

Регистрация пользователя через основного бота.

Проверка подписки на канал.

Выдача и погашение скидок.

Авторизация кассира и работа кассирского бота.

Создание сегментов, кампаний, рассылок.

Работа фоновых задач (рассылки, ДР, напоминания).

Дашборд и логирование.

15. Как ИИ-агенту выполнять всё это эффективно

Работай по этапам, описанным выше: A → B → C → … → L.

Перед началом очередного этапа:

Ещё раз коротко просканируй структуру проекта.

Выпиши себе список файлов, с которыми будешь работать.

Избегай глобальных переписок и лишнего рефакторинга:

Если задача решается добавлением небольшой функции или поля — делай только это.

После каждой крупной пачки изменений:

Убедись, что проект собирается и запускается.

Если есть тесты — запускай их.

Если при работе на следующем этапе обнаружишь несоответствие предыдущего — сначала аккуратно поправь базовую логику (данные, БД, хранение), потом фронт.

При возникновении неоднозначности:

Ориентируйся на уже реализованные части проекта.

Старайся повторять существующие подходы и структуры.